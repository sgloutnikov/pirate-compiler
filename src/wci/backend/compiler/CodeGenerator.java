package wci.backend.compiler;

import java.util.ArrayList;
import java.io.*;
import java.util.HashMap;

import wci.frontend.*;
import wci.intermediate.*;
import wci.intermediate.symtabimpl.Predefined;
import wci.backend.*;

import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.symtabimpl.DefinitionImpl.*;
import static wci.intermediate.typeimpl.TypeFormImpl.ARRAY;
import static wci.intermediate.typeimpl.TypeFormImpl.ENUMERATION;
import static wci.intermediate.typeimpl.TypeKeyImpl.ARRAY_ELEMENT_TYPE;

/**
 * <p>The code generator for a compiler back end.</p>
 *
 * <p>Copyright (c) 2008 by Ronald Mak; Modified by Tokenizers.</p>
 * <p>For instructional purposes only.  No warranties.</p>
 */
public class CodeGenerator extends Backend
{
    private static final int STACK_LIMIT = 32;
        
    static ICode iCode;
    static SymTabStack symTabStack;
    static PrintWriter objectFile;
    static String programName;
    static HashMap<String,String> globalVariableMap;
    static HashMap<String,String> routineSignatureMap;

    /**
     * Process the intermediate code and the symbol table generated by the
     * parser to generate machine-language instructions.
     * @param iCode the intermediate code.
     * @param symTabStack the symbol table stack.
     * @param objectFile the object file path for the generated code.
     * @throws Exception if an error occurred.
     */
    public void process(ICode iCode, SymTabStack symTabStack,
                        String objectFilePath)
        throws Exception
    {
   	 CodeGenerator.iCode       = iCode;
   	 CodeGenerator.symTabStack = symTabStack;
   	 CodeGenerator.objectFile  = new PrintWriter(objectFilePath);
   	 CodeGenerator.globalVariableMap = new HashMap<String,String>();
   	 CodeGenerator.routineSignatureMap = new HashMap<String,String>();

        // Make the program and method names.
        int start = objectFilePath.lastIndexOf("/") + 1;
        programName = objectFilePath.substring(start);
        int end = programName.indexOf(".");
        if (end > -1) {
           programName = programName.substring(0, end);
       }
       programName = programName.substring(0, 1).toUpperCase() +
                     programName.substring(1);
       
       SymTabEntry programId = symTabStack.getProgramId();
       int localsCount = 
               (Integer) programId.getAttribute(ROUTINE_LOCALS_COUNT);
       SymTab routineSymTab = 
                (SymTab) programId.getAttribute(ROUTINE_SYMTAB);
        ArrayList<SymTabEntry> locals = routineSymTab.sortedEntries();

        // Generate the header code.
        objectFile.println(".class public " + programName);
        objectFile.println(".super java/lang/Object");
        objectFile.println();
        
        // Generate the .field lines.
        for (SymTabEntry id : locals) {
            Definition defn = id.getDefinition();
            if ((defn == VARIABLE) && (id.getIndex() == -1)) {
                String localName = id.getName();
                TypeSpec type = id.getTypeSpec();
                String typeCode = typeDescriptor(type);
                StringBuffer fieldCode = new StringBuffer(".field private static ");
                fieldCode.append(localName);
                fieldCode.append(" ");
                fieldCode.append(typeCode);
                // check if global variable is initialized
                if (id.getAttribute(DATA_VALUE) != null) {
               	 // since we are using static fields, we can initialize the global variables
               	 fieldCode.append(" = ");
               	 if (type == Predefined.booleanType) {
               		 String booleanValue = (String) id.getAttribute(DATA_VALUE);
               		 fieldCode.append(booleanValue.equals("true") ? "1" : "0");
               	} else {
               		fieldCode.append(id.getAttribute(DATA_VALUE));
               	}
                }
                objectFile.println(fieldCode.toString());
                objectFile.flush();
                globalVariableMap.put(localName, typeCode);
            }
        }
        objectFile.println();
        
        // Generate code for main program's constructor.
        objectFile.println(".method public <init>()V");
        objectFile.println();
        objectFile.println("    aload_0");
        objectFile.println("    invokenonvirtual	java/lang/Object/<init>()V");
        objectFile.println("    return");
        objectFile.println();
        objectFile.println(".limit locals 1");
        objectFile.println(".limit stack 1");
        objectFile.println(".end method");
        objectFile.println();
        objectFile.flush();
        
       // Generate code for each nested procedure or function.
       for (SymTabEntry id : locals) {
      	 
          // Generate the .var lines.
      	 Definition defn = id.getDefinition();
      	 
      	 if (defn == FUNCTION || defn == PROCEDURE) {
         	 TypeSpec returnType = null;
         	 
      		 // Generate code for routine header
         	 String routineName = id.getName();
         	 objectFile.print(".method public static ");
         	 StringBuffer routineHeader = new StringBuffer(routineName);
         	 routineHeader.append("(");
         	 
         	 // Get the routine's locals count and symbol table
             int routineLocalsCount = 
                (Integer) id.getAttribute(ROUTINE_LOCALS_COUNT);
             SymTab funcOrProcSymTab = 
                (SymTab) id.getAttribute(ROUTINE_SYMTAB);
             ArrayList<SymTabEntry> funcOrProcLocals = funcOrProcSymTab.sortedEntries();
         	 
         	 // Append parameter information in descriptor
             for (SymTabEntry localId : funcOrProcLocals) {
            	 Definition localDefn = localId.getDefinition();
            	 if ((localDefn == VAR_PARM) || (localDefn == VALUE_PARM)) { // TODO decide which parm passing policy to use
            		 TypeSpec type = localId.getTypeSpec();
	         		 routineHeader.append(typeDescriptor(type));
         		 }
             }
         	 routineHeader.append(")");
         	 
         	 // Append return type information in descriptor	 
         	 if (defn == FUNCTION) {
         		 // append return value to header 
         		 returnType = id.getTypeSpec();
         		 routineHeader.append(typeDescriptor(returnType));
         	 } else {
         		 // procedure has return type Void
         		 routineHeader.append("V");
         	 }
         	 objectFile.println(routineHeader.toString());
      		
         	 // save routine signature for use with routine calls
         	 routineSignatureMap.put(routineName, routineHeader.toString());
         	 
             // Generate the .var lines for the routine
             for (SymTabEntry localVarId : funcOrProcLocals) {  
            	 Definition localVarDefn = localVarId.getDefinition();
         	 if ((localVarDefn == VARIABLE) || (localVarDefn == VAR_PARM) || (localVarDefn == VALUE_PARM)) {
         		 String localVarName = localVarId.getName();
         		 int localVarIndex = localVarId.getIndex();
         		 TypeSpec type = localVarId.getTypeSpec();
         		 String typeCode = typeDescriptor(type);
         		 objectFile.println(".var " + localVarIndex + " is " + 
         				 localVarName + " " + typeCode);
         		 }
             }
             
             // Check if any of the local variables are initialized;
             // if so, generate code to set the values
             for (SymTabEntry localVarId : funcOrProcLocals) {  
            	 Definition localVarDefn = localVarId.getDefinition();
         	 if (localVarDefn == VARIABLE && !(localVarId.getAttribute(DATA_VALUE) == null)) {
         		 int localVarIndex = localVarId.getIndex();
         		 objectFile.println("    ; initialize local variable " + localVarIndex);
         		 TypeSpec type = localVarId.getTypeSpec();
         		 String typeCode = typeDescriptor(type).toLowerCase();
         		 String dataValue = (String) localVarId.getAttribute(DATA_VALUE);
            	 // check if type is char or boolean, since those are treated as ints in JVM
            	 if (typeCode.equals("c") || typeCode.equals("z") || typeCode.equals("i")) {
            		 if (typeCode.equals("z")) {
            			 // convert "true" to 1 and "false" to 0
            			 dataValue = dataValue.equals("true") ? "1" : "0";
            		 }
            		 typeCode = "i";
         		 } 
            	 objectFile.println("    " + "ldc " + dataValue);
         		 objectFile.println("    " + typeCode + "store " + localVarIndex);
             	}	
             }
         	 
             // Visit the parse tree nodes to generate code for this routine's body.
             CodeGeneratorVisitor codeVisitor = new CodeGeneratorVisitor();
             Node rootNode = ((ICode) id.getAttribute(ROUTINE_ICODE)).getRoot(); 
             rootNode.jjtAccept(codeVisitor, null);
         	 
             // Generate return code
             if (returnType == null) {
                objectFile.println("    return"); // this will be different for functions TODO
             } else {
            	 String rType = typeDescriptor(returnType).toLowerCase();
            	 // check if return type is char or boolean, since those are treated as ints in JVM
            	 if (rType.equals("c") || rType.equals("z")) {
            		 rType = "i";
            	 }
            	 objectFile.println("    " + rType + "return");
             }
             
             // Generate the footer code.
             objectFile.println();
             objectFile.println(".limit locals " + routineLocalsCount); 
             objectFile.println(".limit stack  " + STACK_LIMIT);
             objectFile.println(".end method");
             objectFile.flush();
             
             objectFile.println();
             objectFile.flush();
             
      	 }
       }
        
       objectFile.println();
       objectFile.flush();

        // Generate code for the weighAnchor procedure is the main procedure -- TODO Wycee
        objectFile.println(".method public static main([Ljava/lang/String;)V");
        
        // Generate the .var lines for local variables in main
        for (SymTabEntry id : locals) {  
       	 Definition defn = id.getDefinition();
    	 if (((defn == VARIABLE) || (defn == VAR_PARM) || (defn == VALUE_PARM))
    			 && id.getIndex() != -1){
    		 String name = id.getName();
    		 int index = id.getIndex();
    		 TypeSpec type = id.getTypeSpec();
    		 String typeCode = typeDescriptor(type);
    		 objectFile.println(".var " + index + " is " + 
    				name + " " + typeCode);
    		 }
        }
        
        // Check if any of the local variables are initialized;
        // if so, generate code to set the values
        for (SymTabEntry id : locals) {  
        	 Definition defn = id.getDefinition();
    	 if (defn == VARIABLE && id.getIndex() != -1 && !(id.getAttribute(DATA_VALUE) == null)) {
    		 int index = id.getIndex();
    		 objectFile.println("    ; initialize local variable " + index);
    		 TypeSpec type = id.getTypeSpec();
    		 String typeCode = typeDescriptor(type).toLowerCase();
   		 String dataValue = (String) id.getAttribute(DATA_VALUE);
       	 // check if type is char or boolean, since those are treated as ints in JVM
       	 if (typeCode.equals("c") || typeCode.equals("z") || typeCode.equals("i")) {
      		 if (typeCode.equals("z")) {
      			 // convert "true" to 1 and "false" to 0
      			 dataValue = dataValue.equals("true") ? "1" : "0";
      		 }
       		 typeCode = "i";
    		 } 
       	 objectFile.println("    " + "ldc " + dataValue);
    		 objectFile.println("    " + typeCode + "store " + index);
        	}	
        }
        
        // Visit the parse tree nodes to generate code.
        CodeGeneratorVisitor codeVisitor = new CodeGeneratorVisitor();
        Node rootNode = iCode.getRoot();
        rootNode.jjtAccept(codeVisitor, null);

        // Generate the footer code.
        objectFile.println("    return");
        objectFile.println();
        //objectFile.println(".limit locals 1"); // main only has one parameter and "local vars" are global .field
        objectFile.println(".limit locals " + localsCount); 
        objectFile.println(".limit stack  " + STACK_LIMIT);
        objectFile.println(".end method");
        objectFile.flush();

        CodeGenerator.objectFile.close();
    }
    
    /**
     * Generate a type descriptor for a data type.
     * @param type the data type.
     * @return the type descriptor.
     */
    protected String typeDescriptor(TypeSpec type)
    {
        TypeForm form = type.getForm();
        StringBuffer buffer = new StringBuffer();

        while ((form == ARRAY) && !type.isPascalString()) {
            buffer.append("[");
            type = (TypeSpec) type.getAttribute(ARRAY_ELEMENT_TYPE);
            form = type.getForm();
        }

        type = type.baseType();

        if (type == Predefined.integerType) {
            buffer.append("I");
        }
        else if (type == Predefined.realType) {
            buffer.append("F");
        }
        else if (type == Predefined.booleanType) {
            buffer.append("Z");
        }
        else if (type == Predefined.charType) {
            buffer.append("C");
        }
        else if (type == Predefined.stringType) { 
            buffer.append("Ljava/lang/String;");
        }
        else if (form == ENUMERATION) { //TODO delete or replace 
            buffer.append("I");
        }
        else /* (form == RECORD) */ { //TODO delete or replace 
            buffer.append("Ljava/util/HashMap;");
        }

        return buffer.toString();
    }
    
}
